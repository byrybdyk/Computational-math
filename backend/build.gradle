
plugins {
    id 'java'
    id 'org.springframework.boot' version '3.2.3'
    id 'io.spring.dependency-management' version '1.1.4'
    id 'org.hidetake.ssh' version '2.11.2'
    
}

import org.hidetake.gradle.ssh.*

group = 'com.example'
version = '0.0.1-SNAPSHOT'

java {
    sourceCompatibility = '17'
}

repositories {
    mavenCentral()
}


dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation('junit:junit:4.13.1')
    implementation 'org.apache.xmlbeans:xmlbeans:5.1.0'
    
    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.2'
    testImplementation 'org.junit.platform:junit-platform-launcher'
    testImplementation 'org.junit.jupiter:junit-jupiter-engine:5.10.2'
    testImplementation 'org.junit.platform:junit-platform-console-standalone:1.10.2'

}



test {
    useJUnitPlatform()


}
task playMusic {
    doLast {
        String audioFilePath = 'C:\\sound.mp3'

        exec {
            commandLine 'cmd', '/c', audioFilePath
        }
    }
}

build.finalizedBy(playMusic)

task validateXmlFiles {
    doLast {
        FileTree xmlFiles = fileTree(dir: 'src/main/resources', include: '**/*.xml')

        xmlFiles.each { xmlFile ->
            try {
                def xml = new XmlParser().parse(xmlFile)
                println "File ${xmlFile.name} is valid XML."
            } catch (Exception e) {
                throw new GradleException("Validation failed for file ${xmlFile.name}: ${e.message}", e)
            }
        }
    }
}

// task convertToNative2Ascii {
//     inputs.files fileTree('src/main/resources') // Входные файлы
//     outputs.dir 'src/main/resources-ascii' // Выходная директория

//     doLast {
//         def srcDir = 'src/main/resources'
//         def destDir = 'src/main/resources-ascii'

//         // Создаем выходную директорию, если ее нет
//         // destDir.mkdirs()

//         // Получаем список всех файлов в исходной директории
//         fileTree(srcDir).each { file ->
//             // Имя файла без расширения
//             def fileName = file.name.replaceAll(/\.xml$/, '.properties')

//             // Преобразуем файл в формат native2ascii
//             def asciiFile = new File("${destDir}/${fileName}")
//             asciiFile.withWriter { writer ->
//                 file.eachLine { line ->
//                     writer.write(line.getBytes('ISO-8859-1').encodeHex().toString() + '\n')
//                 }
//             }
//         }
//     }
// }

// // Добавляем задачу convertToNative2Ascii в цепочку сборки (build) и компиляции (compileJava)
// compileJava.dependsOn convertToNative2Ascii
// build.dependsOn convertToNative2Ascii
import java.nio.file.Files
import java.nio.file.Paths
import java.nio.file.StandardCopyOption

task report {
    dependsOn test

    doLast {
        def testReportFolder = file("$buildDir/reports/tests/test/")

        if (testReportFolder.exists()) {
            def destinationFolder = file("$projectDir/reports/")

            destinationFolder.mkdirs()

            Files.walk(Paths.get(testReportFolder.toURI())).forEach { path ->
                def relativePath = testReportFolder.toPath().relativize(path)
                def destinationPath = destinationFolder.toPath().resolve(relativePath)
                if (!Files.exists(destinationPath)) {
                    Files.createDirectories(destinationPath)
                }
                if (!Files.isDirectory(path)) {
                    try {
                        Files.copy(path, destinationPath, StandardCopyOption.REPLACE_EXISTING)
                    } catch (IOException e) {
                        println "Failed to copy file: ${e.message}"
                    }
                }
            }
            exec {
                commandLine 'git', 'add', '.'
                workingDir destinationFolder
            }

            exec {
                commandLine 'git', 'commit', '-m', 'Add test reports'
                workingDir destinationFolder
            }

            println "Test reports copied successfully."
        } else {
            println "Test report folder does not exist: ${testReportFolder}"
        }
    }
}


tasks.withType(JavaCompile) {
    doFirst {
        // Сохраняем результат компиляции в переменной compileResult
        project.ext.compileResult = didWork
    }
}
task history {
    // dependsOn compileJava
    doLast {
        def success = false
        try {
            exec {
            workingDir projectDir
            commandLine 'cmd', '/c', 'gradlew', 'compileJava'
            }
            success = true
        } catch (Exception e) {
            println "Compile error: ${e.message}"
            success = false
        }
        println "Compile result: $success"
        if (!success) {
            // Максимальное количество попыток загрузки предыдущей версии из репозитория git
            // Путь к файлу, в который будет записан результат операции diff
            def diffFile = file("$buildDir/diff.txt")

            // Счетчик попыток
            // Флаг, указывающий, была ли успешно загружена предыдущая версия
            def successfullyLoaded = false

            // Запускаем цикл попыток
            while (!successfullyLoaded) {

                // Загружаем предыдущую версию из репозитория git
                exec {
                    commandLine 'git', 'checkout', 'HEAD~1'
                    // Рабочая директория для команды git
                    workingDir projectDir
                    // Игнорируем ошибку, если HEAD~1 не существует
                    ignoreExitValue true
                }

                // Проверяем, удалось ли скомпилировать проект
                try {
                    exec {
                    orkingDir projectDir
                    commandLine 'cmd', '/c', 'gradlew', 'compileJava'
                    }
                    success = true
                } catch (Exception e) {
                    success = false
                }
                if (!success) {
                    // Проект не удалось скомпилировать
                    println "Failed to compile project, retrying..."

                    

                    exec {
                        commandLine 'git', 'diff'
                        workingDir projectDir
                        standardOutput = new FileOutputStream($projectDir)
                    }
                    // Ждем некоторое время перед следующей попыткой
                    TimeUnit.SECONDS.sleep(5)
                }

                    
                else {
                    // Проект успешно скомпилирован
                    println "Project compiled successfully, diff in ${diffFile}"
                    successfullyLoaded = true
                }
                
            }

            // Если проект не удалось скомпилировать и была получена самая первая ревизия из репозитория, выходим с ошибкой

        }
        else{
            println "Project compiled successfully, no need to load previous revision"
        }
    }
}






ssh.settings {
    identity = new File('C:\\users\\byrybdyk\\.ssh\\id_rsa')
}

remotes {
    webServer {
        host = '5.42.73.110'
        user = 'byrybdyk'
    }
}
//
task deployJar {
    doLast {
        ssh.run {
            session(remotes.webServer) {
                // Execute a command
//                def result = execute 'sudo service status'

                // Any Gradle methods or properties are available in a session closure
                copy {
                    from "D:\\GIT\\Computational-math\\WebMathbuild\\libs\\WebMath-0.0.1-SNAPSHOT.jar"
                    into "/home/byrybdyk/deploy"
                }

                put from: 'D:\\GIT\\Computational-math\\WebMath\\build\\libs\\WebMath-0.0.1-SNAPSHOT.jar', into:'/home/byrybdyk/deploy'
                // Also Groovy methods or properties are available in a session closure
            }
        }
    }
}
