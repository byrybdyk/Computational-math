
plugins {
    id 'java'
    id 'org.springframework.boot' version '3.2.3'
    id 'io.spring.dependency-management' version '1.1.4'
    id 'org.hidetake.ssh' version '2.11.2'
    
}

import org.hidetake.gradle.ssh.*

group = 'com.example'
version = '0.0.1-SNAPSHOT'

java {
    sourceCompatibility = '17'
}

repositories {
    mavenCentral()
}


dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation('junit:junit:4.13.1')
    implementation 'org.apache.xmlbeans:xmlbeans:5.1.0'
    
    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.2'
    testImplementation 'org.junit.platform:junit-platform-launcher'
    testImplementation 'org.junit.jupiter:junit-jupiter-engine:5.10.2'
    testImplementation 'org.junit.platform:junit-platform-console-standalone:1.10.2'

}



test {
    useJUnitPlatform()


}
task playMusic {
    dependsOn build
    doLast {
        String audioFilePath = 'C:\\sound.mp3'

        exec {
            commandLine 'cmd', '/c', audioFilePath
        }
    }
}


task validateXmlFiles {
    doLast {
        FileTree xmlFiles = fileTree(dir: 'src/main/resources', include: '**/*.xml')

        xmlFiles.each { xmlFile ->
            try {
                def xml = new XmlParser().parse(xmlFile)
                println "File ${xmlFile.name} is valid XML."
            } catch (Exception e) {
                throw new GradleException("Validation failed for file ${xmlFile.name}: ${e.message}", e)
            }
        }
    }
}


import java.nio.file.Files
import java.nio.file.Paths
import java.nio.file.StandardCopyOption

task report {
    dependsOn test

    doLast {
        def testReportFolder = file("$buildDir/reports/tests/test/")

        if (testReportFolder.exists()) {
            def destinationFolder = file("$projectDir/reports/")

            destinationFolder.mkdirs()

            Files.walk(Paths.get(testReportFolder.toURI())).forEach { path ->
                def relativePath = testReportFolder.toPath().relativize(path)
                def destinationPath = destinationFolder.toPath().resolve(relativePath)
                if (!Files.exists(destinationPath)) {
                    Files.createDirectories(destinationPath)
                }
                if (!Files.isDirectory(path)) {
                    try {
                        Files.copy(path, destinationPath, StandardCopyOption.REPLACE_EXISTING)
                    } catch (IOException e) {
                        println "Failed to copy file: ${e.message}"
                    }
                }
            }
            exec {
                commandLine 'git', 'add', '.'
                workingDir destinationFolder
            }

            exec {
                commandLine 'git', 'commit', '-m', 'Add test reports'
                workingDir destinationFolder
            }

            println "Test reports copied successfully."
        } else {
            println "Test report folder does not exist: ${testReportFolder}"
        }
    }
}



tasks.withType(JavaCompile) {
    doFirst {
        // Сохраняем результат компиляции в переменной compileResult
        project.ext.compileResult = didWork
    }
}
task history {
    // dependsOn compileJava
    doLast {
        def success = false
        def diffResult = ""
        def outputStream
        def count =0
        def main_commit = 'HEAD'
        def commit = 'HEAD'
        def prevCommit = commit + '^'
        try {
            exec {
            workingDir projectDir
            commandLine 'cmd', '/c', 'gradlew', 'compileJava'
            }
            success = true
        } catch (Exception e) {
            println "Compile error: ${e.message}"
            success = false
        }
        println "Compile result: $success"
        if (!success) {
            // Максимальное количество попыток загрузки предыдущей версии из репозитория git
            // Путь к файлу, в который будет записан результат операции diff
            def diffFile = file("$buildDir/diff.txt")

            // Счетчик попыток
            // Флаг, указывающий, была ли успешно загружена предыдущая версия
            def successfullyLoaded = false

            // Запускаем цикл попыток
            while (!successfullyLoaded) {

                if(count ==0){
                    outputStream = new ByteArrayOutputStream()
                        exec {
                            
                            commandLine 'git', 'diff'
                            workingDir projectDir
                            standardOutput = outputStream
                        }
                    diffResult = outputStream.toString()
                    count = 1
                    exec {
                        commandLine 'git', 'reset','--hard',commit
                        // Рабочая директория для команды git
                        workingDir projectDir
                        // Игнорируем ошибку, если HEAD~1 не существует
                        ignoreExitValue true
                    }
                }
                else{
                        exec {
                            
                            commandLine 'git', 'diff', prevCommit, commit
                            workingDir projectDir
                            standardOutput = outputStream
                        }
                    diffResult = outputStream.toString()
                        exec {
                        commandLine 'git', 'reset','--hard', prevCommit
                        // Рабочая директория для команды git
                        workingDir projectDir
                        // Игнорируем ошибку, если HEAD~1 не существует
                        ignoreExitValue true
                    }
                    
                }
                // Загружаем предыдущую версию из репозитория git
                
                // Проверяем, удалось ли скомпилировать проект
                if (!success) {
                    // Проект не удалось скомпилировать
                    println "Failed to compile project, retrying..."
                    commit = prevCommit
                    prevCommit += '^'

                    
                    
                }

                    
                else {
                    // Проект успешно скомпилирован
                    println "Project compiled successfully, diff in ${diffFile}"
                    successfullyLoaded = true

                    def outputFile = new File("diff.txt")
                    outputFile.write(diffResult)

                    // exec {
                    //     commandLine 'git', 'reset','--hard', main_commit
                    //     // Рабочая директория для команды git
                    //     workingDir projectDir
                    //     // Игнорируем ошибку, если HEAD~1 не существует
                    //     ignoreExitValue true
                    // }
                    // println "Return to main branch ${main_commit}"
                }
                
            }

            // Если проект не удалось скомпилировать и была получена самая первая ревизия из репозитория, выходим с ошибкой

        }
        else{
            println "Project compiled successfully, no need to load previous revision"
            
        }
    }
}

task native2ascii {
    def inputDir = file('src/main/resources/asciiOld')
    def outputDir = file('src/main/resources/asciiNew/')

    doLast {
        ant.native2ascii(
            src : project.file(inputDir),
            dest : project.file(outputDir) 
        )
    }
}

task env {
    // Версия Java
    def javaVersion = "17" // Здесь можно указать нужную версию Java

    // Аргументы виртуальной машины
    def jvmArg1 = "-Xmx1024m" // Пример аргументов

    def jvmArg2 = "-Xms256m"

    doLast {
        // Определяем путь к исполняемому файлу Java
        def javaExec = "\"C:\\Program Files\\Java\\jdk-${javaVersion}\\bin\\java.exe\""
        println("Java executable: ${javaExec}")


        exec {
            workingDir projectDir
            // Используем call для корректного запуска пути с пробелами
            commandLine 'cmd', '/c', 'call', javaExec,'-jar', jvmArg1,jvmArg2, 'build/libs/WebMath-0.0.1-SNAPSHOT.jar'
        }
    }
}









ssh.settings {
    identity = new File('C:\\users\\byrybdyk\\.ssh\\id_rsa')
}

remotes {
    webServer {
        host = '5.42.73.110'
        user = 'byrybdyk'
    }
}
//
task deployJar {
    doLast {
        ssh.run {
            session(remotes.webServer) {
                // Execute a command
//                def result = execute 'sudo service status'

                // Any Gradle methods or properties are available in a session closure
                copy {
                    from "D:\\GIT\\Computational-math\\WebMathbuild\\libs\\WebMath-0.0.1-SNAPSHOT.jar"
                    into "/home/byrybdyk/deploy"
                }

                put from: 'D:\\GIT\\Computational-math\\WebMath\\build\\libs\\WebMath-0.0.1-SNAPSHOT.jar', into:'/home/byrybdyk/deploy'
                // Also Groovy methods or properties are available in a session closure
            }
        }
    }
}
